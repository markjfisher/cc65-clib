#!/usr/bin/env python3
"""
Python equivalent of clib_imports.pl

Builds a set of imports and a jump table of symbols by analyzing
cc65 object file information (.info files generated by od65).

Usage: clib_imports.py <rom_import.s> <rom_jumps.s> <include_objs.lst> <exclude_objs.lst> [input.info...]
"""

import sys
import os
import re
from collections import defaultdict
from typing import Dict, Set, List, Tuple


def usage(msg: str):
    """Print usage message and exit."""
    print(f"{sys.argv[0]} <rom_import.s> <rom_jumps.s> <include_objs.lst> <exclude_objs.lst> [input.info...]", file=sys.stderr)
    print(file=sys.stderr)
    sys.exit(msg)


class InfoParser:
    """Parse cc65 .info files generated by od65 --dump-all."""
    
    # Allowed segment names for ROM inclusion
    ALLOWED_SEGMENTS = {"CODE", "RODATA", "NULL", "ZEROPAGE"}
    
    def __init__(self):
        self.file_imports: Dict[str, List[str]] = {}
        self.file_exports: Dict[str, List[str]] = {}
        self.excluded_files: Set[str] = set()
        self.allowed_files: Set[str] = set()
        self.zp_exports: Set[str] = set()
    
    def parse_info_file(self, filename: str) -> None:
        """Parse a single .info file."""
        print(f"scanning {filename}")
        
        try:
            with open(filename, 'r') as f:
                content = f.read()
        except IOError as e:
            usage(f"Cannot open {filename} for input: {e}")
        
        imports = []
        exports = []
        self.allowed_files.add(filename)
        
        # Parse segments to check for disallowed segment usage
        segments_section = self._extract_section(content, "Segments:")
        if segments_section:
            self._parse_segments(filename, segments_section)
        
        # Parse imports
        imports_section = self._extract_section(content, "Imports:")
        if imports_section:
            imports = self._parse_imports_exports(imports_section)
        
        # Parse exports  
        exports_section = self._extract_section(content, "Exports:")
        if exports_section:
            exports = self._parse_imports_exports(exports_section)
        
        self.file_imports[filename] = imports
        self.file_exports[filename] = exports
    
    def _extract_section(self, content: str, section_name: str) -> str:
        """Extract a section from the .info file content."""
        lines = content.split('\n')
        in_section = False
        section_lines = []
        
        for line in lines:
            # Look for the actual section data, not the header offsets
            # The real sections start with exactly "  Imports:" or "  Exports:" (two spaces)
            if line == f'  {section_name}':
                in_section = True
                continue
            elif in_section and line.startswith('  ') and ':' in line and not line.startswith('    '):
                # New section starting (two spaces, has colon, not indented further)
                break
            elif in_section:
                section_lines.append(line)
        
        return '\n'.join(section_lines)
    
    def _parse_segments(self, filename: str, segments_section: str) -> None:
        """Parse segments section and exclude files with disallowed segments."""
        lines = segments_section.split('\n')
        current_segment = None
        
        for line in lines:
            line = line.strip()
            
            # Look for segment name
            name_match = re.match(r'Name:\s*"([^"]+)"', line)
            if name_match:
                current_segment = name_match.group(1)
                continue
            
            # Look for size > 0
            size_match = re.match(r'Size:\s*(\d+)', line)
            if size_match and current_segment:
                size = int(size_match.group(1))
                if size > 0 and current_segment not in self.ALLOWED_SEGMENTS:
                    self.excluded_files.add(filename)
                    self.allowed_files.discard(filename)
                    print(f"; file {filename} uses disallowed segment {current_segment}")
                    return
    
    def _parse_imports_exports(self, section: str) -> List[str]:
        """Parse imports or exports section, returning list of symbols."""
        symbols = []
        lines = section.split('\n')
        is_zeropage = False
        
        for line in lines:
            line = line.strip()
            
            # Check for address size
            if 'Address size:' in line:
                is_zeropage = 'zeropage' in line
                continue
            
            # Look for symbol name
            name_match = re.match(r'Name:\s*"([^"]+)"', line)
            if name_match:
                symbol_name = name_match.group(1)
                if is_zeropage:
                    self.zp_exports.add(symbol_name)
                else:
                    symbols.append(symbol_name)
        
        return symbols
    
    def resolve_dependencies(self) -> None:
        """Exclude files that depend on excluded symbols."""
        changed = True
        
        while changed:
            changed = False
            
            # Build set of excluded symbols
            excluded_symbols = set()
            for filename in self.excluded_files:
                for symbol in self.file_exports.get(filename, []):
                    excluded_symbols.add(symbol)
            
            # Build set of included symbols
            included_symbols = set()
            for filename in self.allowed_files:
                for symbol in self.file_exports.get(filename, []):
                    included_symbols.add(symbol)
            
            # Check each allowed file's dependencies
            to_exclude = set()
            for filename in self.allowed_files:
                for symbol in self.file_imports.get(filename, []):
                    if (symbol not in included_symbols and 
                        symbol not in self.zp_exports and
                        symbol not in excluded_symbols):
                        # Symbol not found anywhere - exclude this file
                        print(f"; file {filename} relies on symbol {symbol} which is not in the library")
                        to_exclude.add(filename)
                        break
                    elif symbol in excluded_symbols:
                        # Symbol is in excluded file
                        print(f"; file {filename} relies on symbol {symbol} which is in excluded file")
                        to_exclude.add(filename)
                        break
            
            if to_exclude:
                changed = True
                for filename in to_exclude:
                    self.excluded_files.add(filename)
                    self.allowed_files.discard(filename)
    
    def generate_outputs(self, imports_file: str, jumps_file: str, 
                        include_objs_file: str, exclude_objs_file: str,
                        rom_manifest_file: str = None, excluded_manifest_file: str = None) -> None:
        """Generate all output files and optional manifest files."""
        
        # Collect all exports from allowed files
        my_exports_runtime = {}
        for filename in self.allowed_files:
            for symbol in self.file_exports.get(filename, []):
                my_exports_runtime[symbol] = filename
        
        # Generate include objects list
        with open(include_objs_file, 'w') as f:
            for filename in sorted(self.allowed_files):
                obj_filename = filename.replace('.info', '.o')
                f.write(f"{obj_filename} ")
        
        # Generate exclude objects list
        with open(exclude_objs_file, 'w') as f:
            for filename in sorted(self.excluded_files):
                obj_filename = filename.replace('.info', '.o')
                f.write(f"{obj_filename} ")
        
        # Generate imports file
        with open(imports_file, 'w') as f:
            f.write("; generated by clib_imports.py\n")
            
            for symbol in sorted(my_exports_runtime.keys()):
                if symbol:
                    source_file = my_exports_runtime[symbol]
                    f.write(f"\n\t\t.import\t{symbol}\t;\t{source_file}\n")
                    f.write(f"\n\t\tFORCE_{symbol}={symbol}\n")
            
            f.write("; The following files and symbols were ignored due to using data\n")
            
            for filename in sorted(self.excluded_files):
                f.write(f";\t{filename}\n")
                for symbol in sorted(self.file_exports.get(filename, [])):
                    f.write(f";\t\t.export {symbol}\n")
                for symbol in sorted(self.file_imports.get(filename, [])):
                    f.write(f";\t\t.import {symbol}\t\t;{filename}\n")
            
            f.write("\n")
        
        # Generate jumps file (currently empty like the Perl version)
        with open(jumps_file, 'w') as f:
            f.write("; generated by clib_imports.py\n")
            f.write("\n")
        
        # Generate ROM manifest file (functions available in ROM)
        if rom_manifest_file:
            with open(rom_manifest_file, 'w') as f:
                f.write("# Functions available in cc65 CLIB ROM\n")
                f.write("# Generated by clib_imports.py\n")
                for symbol in sorted(my_exports_runtime.keys()):
                    if symbol:
                        f.write(f"{symbol}\n")
        
        # Generate excluded manifest file (functions that need to be local)
        if excluded_manifest_file:
            with open(excluded_manifest_file, 'w') as f:
                f.write("# Functions excluded from ROM (need local implementation)\n") 
                f.write("# Generated by clib_imports.py\n")
                excluded_symbols = set()
                for filename in self.excluded_files:
                    for symbol in self.file_exports.get(filename, []):
                        if symbol:
                            excluded_symbols.add(symbol)
                for symbol in sorted(excluded_symbols):
                    f.write(f"{symbol}\n")


def main():
    """Main entry point."""
    if len(sys.argv) < 5:
        usage("insufficient arguments")
    
    imports_file = sys.argv[1]
    jumps_file = sys.argv[2] 
    include_objs_file = sys.argv[3]
    exclude_objs_file = sys.argv[4]
    info_files = sys.argv[5:]
    
    if not info_files:
        usage("no input .info files specified")
    
    parser = InfoParser()
    
    # Parse all info files
    for info_file in info_files:
        parser.parse_info_file(info_file)
    
    # Resolve dependencies
    parser.resolve_dependencies()
    
    # Generate output files (with optional manifests in same directory as include_objs_file)
    manifest_dir = os.path.dirname(include_objs_file)
    rom_manifest_file = os.path.join(manifest_dir, "rom_functions.manifest")
    excluded_manifest_file = os.path.join(manifest_dir, "excluded_functions.manifest")
    
    parser.generate_outputs(imports_file, jumps_file, include_objs_file, exclude_objs_file, 
                          rom_manifest_file, excluded_manifest_file)


if __name__ == "__main__":
    main()
