#!/usr/bin/env python3
"""
Builds a set of imports and a jump table of symbols by analyzing
cc65 object file information (.info files generated by od65).

Usage:
  clib_imports.py <rom_import.s> <rom_jumps.s> <include_objs.lst> <exclude_objs.lst> [input.info...]
Optional:
  --cc65-libsrc <PATH>      # path to upstream cc65/libsrc to compute FINAL list
  --target bbc|bbc-clib     # target whose dirs to scan (default: bbc-clib)
"""

import sys
import os
import re
from typing import Dict, Set, List


def usage(msg: str):
    print(f"{sys.argv[0]} <rom_import.s> <rom_jumps.s> <include_objs.lst> <exclude_objs.lst> [input.info...] [--cc65-libsrc PATH] [--target bbc|bbc-clib]", file=sys.stderr)
    sys.exit(msg)


class InfoParser:
    # Allowed segment names for ROM inclusion
    ALLOWED_SEGMENTS = {"CODE", "RODATA", "NULL", "ZEROPAGE"}

    def __init__(self):
        self.file_imports: Dict[str, List[str]] = {}
        self.file_exports: Dict[str, List[str]] = {}
        self.excluded_files: Set[str] = set()
        self.allowed_files: Set[str] = set()
        self.all_info_files: List[str] = []
        self.zp_exports: Set[str] = set()

    def parse_info_file(self, filename: str) -> None:
        print(f"scanning {filename}")
        try:
            with open(filename, 'r') as f:
                content = f.read()
        except IOError as e:
            usage(f"Cannot open {filename} for input: {e}")

        imports: List[str] = []
        exports: List[str] = []
        self.allowed_files.add(filename)
        self.all_info_files.append(filename)

        segments_section = self._extract_section(content, "Segments:")
        if segments_section:
            self._parse_segments(filename, segments_section)

        imports_section = self._extract_section(content, "Imports:")
        if imports_section:
            imports = self._parse_imports_exports(imports_section)

        exports_section = self._extract_section(content, "Exports:")
        if exports_section:
            exports = self._parse_imports_exports(exports_section)

        self.file_imports[filename] = imports
        self.file_exports[filename] = exports

    def _extract_section(self, content: str, section_name: str) -> str:
        lines = content.split('\n')
        in_section = False
        out: List[str] = []
        for line in lines:
            if line == f'  {section_name}':
                in_section = True
                continue
            elif in_section and line.startswith('  ') and ':' in line and not line.startswith('    '):
                break
            elif in_section:
                out.append(line)
        return '\n'.join(out)

    def _parse_segments(self, filename: str, segments_section: str) -> None:
        lines = segments_section.split('\n')
        current = None
        for line in lines:
            line = line.strip()
            m = re.match(r'Name:\s*"([^"]+)"', line)
            if m:
                current = m.group(1)
                continue
            m = re.match(r'Size:\s*(\d+)', line)
            if m and current:
                size = int(m.group(1))
                if size > 0 and current not in self.ALLOWED_SEGMENTS:
                    self.excluded_files.add(filename)
                    self.allowed_files.discard(filename)
                    print(f"; file {filename} uses disallowed segment {current}")
                    return

    def _parse_imports_exports(self, section: str) -> List[str]:
        symbols: List[str] = []
        lines = section.split('\n')
        is_zp = False
        for line in lines:
            line = line.strip()
            if 'Address size:' in line:
                is_zp = ('zeropage' in line)
                continue
            m = re.match(r'Name:\s*"([^"]+)"', line)
            if m:
                name = m.group(1)
                if is_zp:
                    self.zp_exports.add(name)
                else:
                    symbols.append(name)
        return symbols

    def resolve_dependencies(self) -> None:
        changed = True
        while changed:
            changed = False
            excluded_syms = {s for f in self.excluded_files for s in self.file_exports.get(f, [])}
            included_syms = {s for f in self.allowed_files  for s in self.file_exports.get(f, [])}
            to_exclude: Set[str] = set()
            for f in self.allowed_files:
                for sym in self.file_imports.get(f, []):
                    if (sym not in included_syms and sym not in self.zp_exports and sym not in excluded_syms):
                        print(f"; file {f} relies on symbol {sym} which is not in the library")
                        to_exclude.add(f); break
                    elif sym in excluded_syms:
                        print(f"; file {f} relies on symbol {sym} which is in excluded file")
                        to_exclude.add(f); break
            if to_exclude:
                changed = True
                for f in to_exclude:
                    self.excluded_files.add(f)
                    self.allowed_files.discard(f)

    # -------- NEW: scan cc65/libsrc to compute final basenames for bbc-clib --------

    COMMON_SRCDIRS = ["common","conio","dbg","em","joystick","mouse","runtime","serial","tgi","zlib"]

    def scan_cc65_libsrc_basenames(self, cc65_libsrc: str, target: str) -> Set[str]:
        """
        Return basenames (e.g., 'printf.o') for all *.s and *.c directly under
        the directories cc65's Makefile would include for the given target.
        Non-recursive, to mirror wildcards like dir/*.s.
        """
        dirs: List[str] = []
        # Shared installers + per-target common live under bbc/brk/...
        installers = ["bbc/brk/installers"]
        if target == "bbc":
            dirs += ["bbc", "bbc/oslib"] + self.COMMON_SRCDIRS + installers + ["bbc/brk/bbc"]
        else:  # bbc-clib
            # You already avoid bbc/oslib for bbc-clib; keep it out.
            dirs += ["bbc","bbc-clib"] + self.COMMON_SRCDIRS + installers + ["bbc/brk/bbc-clib"]

        basenames: Set[str] = set()
        for d in dirs:
            root = os.path.join(cc65_libsrc, d)
            if not os.path.isdir(root):
                continue
            for name in os.listdir(root):
                if name.lower().endswith(('.s','.c')):
                    base = os.path.splitext(name)[0] + ".o"
                    basenames.add(base)
        return basenames

    # -----------------------------------------------------------------------------

    def generate_outputs(
        self,
        imports_file: str,
        jumps_file: str,
        include_objs_file: str,
        exclude_objs_file: str,
        rom_manifest_file: str = None,
        excluded_manifest_file: str = None,
        cc65_libsrc: str = None,
        target: str = "bbc-clib"
    ) -> None:
        # figure out sibling paths for manifests if not provided
        out_dir = os.path.dirname(os.path.abspath(include_objs_file))
        if rom_manifest_file is None:
            rom_manifest_file = os.path.join(out_dir, "rom_functions.manifest")
        if excluded_manifest_file is None:
            excluded_manifest_file = os.path.join(out_dir, "excluded_functions.manifest")

        # Exports from allowed files (ROM)
        my_exports_runtime: Dict[str, str] = {}
        for f in self.allowed_files:
            for sym in self.file_exports.get(f, []):
                if sym:
                    my_exports_runtime[sym] = f

        # include_objs.lst (space-separated, as before)
        with open(include_objs_file, 'w') as f:
            for fname in sorted(self.allowed_files):
                f.write(fname.replace('.info','.o') + " ")

        # exclude_objs.lst (space-separated, as before)
        with open(exclude_objs_file, 'w') as f:
            for fname in sorted(self.excluded_files):
                f.write(fname.replace('.info','.o') + " ")

        # considered_objs.lst (basenames, one per line)
        considered_dir = os.path.dirname(include_objs_file)
        considered_path = os.path.join(considered_dir, "considered_objs.lst")
        considered_basenames = sorted({ os.path.basename(p).replace(".info",".o") for p in set(self.all_info_files) })
        with open(considered_path, 'w') as f:
            for base in considered_basenames:
                f.write(base + "\n")

        # imports/jumps files (unchanged)
        with open(imports_file, 'w') as f:
            f.write("; generated by clib_imports.py\n")
            for sym in sorted(my_exports_runtime.keys()):
                src = my_exports_runtime[sym]
                f.write(f"\n\t\t.import\t{sym}\t;\t{src}\n")
                f.write(f"\n\t\tFORCE_{sym}={sym}\n")
            f.write("; The following files and symbols were ignored due to using data\n")
            for fname in sorted(self.excluded_files):
                f.write(f";\t{fname}\n")
                for s in sorted(self.file_exports.get(fname, [])):
                    f.write(f";\t\t.export {s}\n")
                for s in sorted(self.file_imports.get(fname, [])):
                    f.write(f";\t\t.import {s}\t\t;{fname}\n")
            f.write("\n")

        with open(jumps_file, 'w') as f:
            f.write("; generated by clib_imports.py\n\n")

        # ROM/Excluded symbol manifests (unchanged)
        if rom_manifest_file:
            with open(rom_manifest_file, 'w') as f:
                f.write("# Functions available in cc65 CLIB ROM\n# Generated by clib_imports.py\n")
                for sym in sorted(my_exports_runtime.keys()):
                    f.write(sym + "\n")

        if excluded_manifest_file:
            with open(excluded_manifest_file, 'w') as f:
                f.write("# Functions excluded from ROM (need local implementation)\n# Generated by clib_imports.py\n")
                excluded_syms = set()
                for fname in self.excluded_files:
                    for s in self.file_exports.get(fname, []):
                        if s: excluded_syms.add(s)
                for s in sorted(excluded_syms):
                    f.write(s + "\n")

        # -------- NEW: final_objs.mk (only if cc65_libsrc provided) ----------
        if cc65_libsrc:
            all_basenames = self.scan_cc65_libsrc_basenames(cc65_libsrc, target=target)
            considered_set = set(considered_basenames)
            excluded_basenames = { os.path.basename(p).replace(".info",".o") for p in self.excluded_files }
            # New files not considered by cc65-clib (auto-include into bbc-clib.lib)
            new_basenames = all_basenames - considered_set
            final_basenames = sorted(excluded_basenames | new_basenames)

            final_mk = os.path.join(considered_dir, "final_objs.mk")
            with open(final_mk, 'w') as f:
                f.write("# Autogenerated by clib_imports.py â€” definitive object basenames for bbc-clib.lib\n")
                f.write("BBC_CLIB_OBJS :=")
                # space-separated basenames
                for b in final_basenames:
                    f.write(f" {b}")
                f.write("\n")

def _ensure_parent_dir(path: str) -> None:
    d = os.path.dirname(os.path.abspath(path))
    if d:
        os.makedirs(d, exist_ok=True)

def main():
    # Expect at least 5 args before options
    if len(sys.argv) < 5:
        usage("insufficient arguments")

    # Required positional args
    imports_file = sys.argv[1]
    jumps_file   = sys.argv[2]
    include_objs_file = sys.argv[3]
    exclude_objs_file = sys.argv[4]

    # Optionals
    cc65_libsrc = None
    target = "bbc-clib"

    # Remaining are either .info files or flags
    info_files: List[str] = []
    i = 5
    while i < len(sys.argv):
        arg = sys.argv[i]
        if arg == "--cc65-libsrc":
            i += 1
            if i >= len(sys.argv):
                usage("missing path after --cc65-libsrc")
            cc65_libsrc = sys.argv[i]
        elif arg == "--target":
            i += 1
            if i >= len(sys.argv):
                usage("missing name after --target")
            target = sys.argv[i]
            if target not in ("bbc", "bbc-clib"):
                usage("target must be 'bbc' or 'bbc-clib'")
        else:
            info_files.append(arg)
        i += 1

    if not info_files:
        usage("no input .info files specified")

    # Ensure output dir exists (others are in same dir)
    _ensure_parent_dir(include_objs_file)
    _ensure_parent_dir(jumps_file)

    parser = InfoParser()

    # Parse all .info files
    for info in info_files:
        parser.parse_info_file(info)

    # Resolve deps and emit outputs
    parser.resolve_dependencies()

    # These manifest paths are derived inside generate_outputs
    parser.generate_outputs(
        imports_file=imports_file,
        jumps_file=jumps_file,
        include_objs_file=include_objs_file,
        exclude_objs_file=exclude_objs_file,
        cc65_libsrc=cc65_libsrc,
        target=target
    )

    # Helpful summary
    print(f"; parsed {len(parser.all_info_files)} info files", file=sys.stderr)
    print(f"; allowed: {len(parser.allowed_files)}, excluded: {len(parser.excluded_files)}", file=sys.stderr)
    print(f"; wrote: {include_objs_file}, {exclude_objs_file}", file=sys.stderr)
    print(f"; wrote manifests and final_objs.mk next to {include_objs_file}", file=sys.stderr)

if __name__ == "__main__":
    main()
