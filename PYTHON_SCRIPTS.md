## Scripts

### `clib_imports.py`

Analyzes cc65 object file information (`.info` files generated by `od65`) to:

- Identify which object files can be included in the ROM vs excluded
- Build import/export dependency graphs
- Generate jump tables and import definitions
- Create lists of included/excluded object files

**Usage:**
```bash
python3 clib_imports.py <rom_import.s> <rom_jumps.s> <include_objs.lst> <exclude_objs.lst> [input.info...]
```

**Algorithm:**
1. Parse each `.info` file to extract segments, imports, and exports
2. Exclude files that use disallowed segments (only CODE, RODATA, NULL, ZEROPAGE allowed)
3. Resolve dependencies - exclude files that import symbols not provided by included files
4. Generate output files with import definitions and object file lists

### `clib_stubs.py`

Extracts symbol information from ld65 map files to create assembler stub definitions.

**Usage:**
```bash
python3 clib_stubs.py <rom_map.map> <output.s>
```

**Algorithm:**
1. Parse the "Exports list by value" section from the map file
2. Extract symbol names, addresses, and types
3. Generate assembler `.export` and `:=` definitions for each symbol
4. Skip internal symbols starting with `__`

## Makefile Integration

```bash
make all
```

## Requirements

### Python
- Python 3.6 or later
- Uses only standard library modules (`sys`, `re`, `typing`, `collections`)

## Implementation Notes

### Info File Parsing
The `.info` files generated by `od65 --dump-all` have a specific structure:
- Header section with file offsets
- Multiple data sections (Segments, Imports, Exports, etc.)
- Imports/Exports sections appear twice - once as headers, once as data
- The Python parser correctly identifies the data sections vs header sections

### Map File Format
ld65 map files contain an "Exports list by value" section with symbol information:
```
Exports list by value:
-----------------------  
symbol1  address1 type1    symbol2  address2 type2
```

The parser handles both single and double symbol lines, extracting the final character of the type field as the actual symbol type (Z=zeropage, A=absolute, etc.).
